"""
UPPAAL Model Generator
Centralized logic for generating UPPAAL XML models from task specifications
"""
import re
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Tuple

class UppaalGenerator:
    def __init__(self):
        pass

    def generate_xml(self, task_info: Dict[str, Any], source_code: str = None) -> Tuple[str, List[Dict]]:
        """
        Generate UPPAAL XML model from task info (single or multi-task).
        
        Args:
            task_info: Dictionary containing task information
            source_code: Optional source code string for hashing/comments
            
        Returns:
            Tuple containing (xml_content_string, properties_list)
        """
        if isinstance(task_info, dict) and task_info.get('multi_task'):
            tasks = task_info.get('tasks', [])
        else:
            # Handle single task or list of tasks wrapped in dict
            if 'tasks' in task_info and isinstance(task_info['tasks'], list):
                 tasks = task_info['tasks']
            else:
                 tasks = [task_info]
        
        if not tasks:
            tasks = [{'task_name': 'Task', 'period': 100, 'deadline': 100, 'execution_time': 50, 'priority': 1}]

        def templates_helper_name(task):
            raw_name = task.get('task_name', task.get('name', 'Task'))
            safe = re.sub(r'[^A-Za-z0-9_]', '_', raw_name)
            if re.match(r'^\d', safe):
                safe = f'T_{safe}'
            return safe if safe.startswith('T_') else f'T_{safe}'
        
        # Sort tasks by priority (lower value = higher priority in some conventions, 
        # but here we assume standard RMS/fixed priority where we might need to check interference)
        # Actually, let's stick to the input order or sort by priority field if needed.
        # The original code sorted by priority.
        tasks_sorted = sorted(tasks, key=lambda t: t.get('priority', 1))
        task_count = len(tasks_sorted)
        multi_task = task_count > 1
        
        global_lines = ["// Auto-generated by UppaalGenerator"]
        if source_code:
            global_lines.append("// Source hash: {}".format(hash(source_code)))
        if multi_task:
            global_lines.append(f"int cpu_owner = -1; // -1 means CPU free")
            global_lines.append(f"int task_scheduled[{task_count}] = {{0}};")
        else:
            global_lines.append("int cpu_owner = -1;")
            global_lines.append("int task_scheduled[1] = {0};")
        
        templates = []
        system_lines = []
        properties_list = [
            {'formula': 'A[] not deadlock', 'comment': 'System has no deadlocks'}
        ]
        
        for idx, task in enumerate(tasks_sorted):
            raw_task_name = task.get('task_name', task.get('name', f'Task_{idx+1}'))
            safe_name = re.sub(r'[^A-Za-z0-9_]', '_', raw_task_name)
            if re.match(r'^\d', safe_name):
                safe_name = f'T_{safe_name}'
            template_name = safe_name if safe_name.startswith('T_') else f'T_{safe_name}'
            instance_name = f"{template_name}_inst"
            
            # Handle different field names
            period = task.get('period') or task.get('period_ms') or 100
            deadline = task.get('deadline') or task.get('deadline_ms') or period
            exec_time = task.get('execution_time') or task.get('execution_ms') or max(1, period // 2)
            task_id = task.get('priority', idx + 1)
            
            higher_checks = ' && '.join([f'!task_scheduled[{j}]' for j in range(idx)])
            guard_parts = ["x >= 0", "cpu_owner == -1"]
            if higher_checks:
                guard_parts.append(higher_checks)
            guard_expr = ' && '.join(guard_parts)
            # Escape XML special characters
            guard_expr_xml = guard_expr.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
            
            acquire_assignments = ["cpu_owner := {}".format(task_id), f"task_scheduled[{idx}] := 1", "x := 0"]
            release_assignments = [f"task_scheduled[{idx}] := 0", "cpu_owner := -1"]
            
            template = f"""
    <template>
        <name>{template_name}</name>
        <declaration>
clock x;
const int PERIOD = {period};
const int DEADLINE = {deadline};
const int EXEC_TIME = {exec_time};
const int TASK_ID = {task_id};
        </declaration>
        <location id="{template_name}_idle" x="-200" y="{idx * 180}">
            <name>Idle</name>
        </location>
        <location id="{template_name}_ready" x="0" y="{idx * 180}">
            <name>Ready</name>
            <label kind="invariant">x &lt;= PERIOD</label>
        </location>
        <location id="{template_name}_exec" x="200" y="{idx * 180}">
            <name>Executing</name>
            <label kind="invariant">x &lt;= EXEC_TIME</label>
        </location>
        <location id="{template_name}_done" x="400" y="{idx * 180}">
            <name>Done</name>
        </location>
        <init ref="{template_name}_idle"/>
        <transition>
            <source ref="{template_name}_idle"/>
            <target ref="{template_name}_ready"/>
            <label kind="assignment">x := 0</label>
        </transition>
        <transition>
            <source ref="{template_name}_ready"/>
            <target ref="{template_name}_exec"/>
            <label kind="guard">{guard_expr_xml}</label>
            <label kind="assignment">{', '.join(acquire_assignments)}</label>
        </transition>
        <transition>
            <source ref="{template_name}_exec"/>
            <target ref="{template_name}_done"/>
            <label kind="guard">x &lt;= DEADLINE</label>
            <label kind="assignment">{', '.join(release_assignments)}</label>
        </transition>
        <transition>
            <source ref="{template_name}_done"/>
            <target ref="{template_name}_idle"/>
            <label kind="assignment">x := 0</label>
        </transition>
    </template>"""
            templates.append(template)
            system_lines.append(f"{instance_name} = {template_name}();")
            properties_list.append({
                'formula': f'A[] ({instance_name}.Executing imply {instance_name}.x <= {deadline})',
                'comment': f'Deadline respected for {raw_task_name}'
            })
            properties_list.append({
                'formula': f'E<> {instance_name}.Done',
                'comment': f'Task {raw_task_name} can complete'
            })
        
        # Mutual exclusion properties if multiple tasks
        if task_count > 1:
            for i in range(task_count):
                for j in range(i + 1, task_count):
                    inst_i = f"{templates_helper_name(tasks_sorted[i])}_inst"
                    inst_j = f"{templates_helper_name(tasks_sorted[j])}_inst"
                    properties_list.append({
                        'formula': f'A[] not ({inst_i}.Executing and {inst_j}.Executing)',
                        'comment': 'Mutual exclusion between tasks'
                    })
        
        def build_system_section():
            instances = '\n'.join(system_lines)
            instance_names = ', '.join([line.split(' = ')[0] for line in system_lines])
            return f"""
    <system>
{instances}
system {instance_names};
    </system>"""
        
        def build_queries_section():
            query_xml = []
            for prop in properties_list:
                # Escape XML special characters
                formula_xml = prop['formula'].replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                comment_xml = prop['comment'].replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                query_xml.append(f"""
        <query>
            <formula>{formula_xml}</formula>
            <comment>{comment_xml}</comment>
        </query>""")
            return "\n".join(query_xml)
        
        xml_content = f"""<?xml version=\"1.0\" encoding=\"utf-8\"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
    <declaration>
{chr(10).join('  ' + line for line in global_lines)}
    </declaration>
{''.join(templates)}
{build_system_section()}
    <queries>
{build_queries_section()}
    </queries>
</nta>
"""
        
        return xml_content, properties_list
