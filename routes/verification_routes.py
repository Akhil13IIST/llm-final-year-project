"""Verification routes for UPPAAL model checking."""
from flask import request, jsonify, send_file, Blueprint
from datetime import datetime
import os

from core.priority_validator import PriorityValidator
from core.schedulability_analyzer import SchedulabilityAnalyzer
import config

verification_bp = Blueprint('verification', __name__)

# Import shared state from app initialization
verifier = None
llm_property_gen = None

def init_verification_routes(app_verifier, app_llm_gen):
    """Initialize routes with verifier and LLM generator instances."""
    global verifier, llm_property_gen
    verifier = app_verifier
    llm_property_gen = app_llm_gen

@verification_bp.route('/verify', methods=['POST'])
def verify():
    """Main verification endpoint."""
    try:
        data = request.json
        ada_code = data.get('ada_code', '')
        nl_requirement = data.get('nl_requirement', '')
        language = data.get('language', 'ada')
        strict_priority = data.get('strict_priority', config.STRICT_PRIORITY_MODE)
        
        # Preserve original input
        original_input = {
            'code': ada_code,
            'requirement': nl_requirement,
            'language': language,
            'timestamp': datetime.now().isoformat()
        }
        
        if not ada_code.strip():
            return jsonify({'error': 'No code provided'}), 400
        
        # Extract task information
        task_info = verifier.extract_from_code(ada_code, language)
        
        # Check if extraction failed
        if isinstance(task_info, dict) and not task_info.get('multi_task') and task_info.get('task_name') == 'Task':
            if nl_requirement and verifier.llm_available:
                print("[WARNING] Extraction failed - attempting LLM feedback regeneration...")
                error_msg = f"Could not extract Period/Deadline constants from {language.upper()} code."
                regenerated_code, regen_error = verifier.regenerate_with_feedback(
                    ada_code, error_msg, nl_requirement, language
                )
                
                if regenerated_code and not regen_error:
                    print("ðŸ”„ Trying extraction with regenerated code...")
                    task_info = verifier.extract_from_code(regenerated_code, language)
                    ada_code = regenerated_code
                    
                    return jsonify({
                        'regenerated': True,
                        'original_code': data.get('ada_code'),
                        'new_code': regenerated_code,
                        'message': f'Code was regenerated by LLM with feedback.',
                        'task_info': task_info,
                        'language': language,
                        'original_input': original_input
                    })
        
        # Get tasks list
        if isinstance(task_info, dict) and task_info.get('multi_task'):
            tasks = task_info['tasks']
        else:
            tasks = [task_info]
        
        # Priority Validation
        priority_validator = PriorityValidator(strict_mode=strict_priority)
        repair_trail = []
        
        tasks = priority_validator.auto_fix_priorities(tasks)
        priority_report = priority_validator.get_report()
        
        # Track priority repairs
        for warning in priority_report.get('warnings', []):
            if 'auto_fixed' in warning.get('message', '').lower():
                repair_trail.append({
                    'type': 'priority_auto_fix',
                    'task': warning.get('task', 'Unknown'),
                    'action': f"Priority changed to {warning.get('fix', 'N/A')} (Rate Monotonic)",
                    'reason': warning.get('message', '')
                })
        
        # Block if strict mode and has errors
        if priority_report.get('has_errors') and strict_priority:
            return jsonify({
                'success': False,
                'error': 'Priority validation failed in strict mode',
                'priority_report': priority_report,
                'task_issues': [
                    {
                        'task_name': t.get('task_name', 'Unknown'),
                        'status': 'error',
                        'icon': 'error',
                        'priority_error': True
                    }
                    for t in tasks
                ],
                'repair_trail': repair_trail,
                'original_input': original_input
            }), 400
        
        # Schedulability Validation
        sched_analyzer = SchedulabilityAnalyzer(allow_unschedulable=config.ALLOW_UNSCHEDULABLE)
        sched_result = sched_analyzer.analyze(tasks)
        
        if not sched_result.is_schedulable and not config.ALLOW_UNSCHEDULABLE:
            adjustments = sched_analyzer.suggest_adjustments(sched_result, tasks)
            
            task_issues = []
            for t in tasks:
                is_failed = t.get('task_name') in sched_result.failed_tasks
                task_issues.append({
                    'task_name': t.get('task_name', 'Unknown'),
                    'status': 'failed' if is_failed else 'ok',
                    'icon': 'failed' if is_failed else 'ok',
                    'priority': t.get('priority', 5),
                    'priority_auto_fixed': t.get('priority_auto_fixed', False)
                })
            
            return jsonify({
                'success': False,
                'error': 'System is not schedulable',
                'task_issues': task_issues,
                'schedulability': {
                    'total_utilization': f"{sched_result.total_utilization*100:.1f}%",
                    'll_bound': f"{sched_result.ll_bound*100:.1f}%",
                    'is_schedulable': False,
                    'failed_tasks': sched_result.failed_tasks,
                    'suggestions': sched_result.suggestions,
                    'llm_feedback': llm_property_gen.generate_schedulability_feedback(
                        tasks if len(tasks) > 1 else tasks[0],
                        sched_result.total_utilization,
                        sched_result.ll_bound
                    ) if config.LLM_FEEDBACK_ENABLED else None
                },
                'adjustments': adjustments,
                'priority_report': priority_report,
                'repair_trail': repair_trail
            }), 400
        
        # Update task_info
        if isinstance(task_info, dict) and task_info.get('multi_task'):
            task_info['tasks'] = tasks
        else:
            task_info = tasks[0]
        
        # Generate task issues for successful case
        task_issues = []
        for t in tasks:
            task_issues.append({
                'task_name': t.get('task_name', 'Unknown'),
                'status': 'ok',
                'icon': 'ok',
                'priority': t.get('priority', 5),
                'priority_auto_fixed': t.get('priority_auto_fixed', False)
            })
        
        # Generate UPPAAL XML
        xml_content, properties_list = verifier.generate_uppaal_xml(task_info)
        
        # Determine task name
        if isinstance(task_info, dict) and task_info.get('multi_task'):
            task_names = [t['task_name'] for t in task_info['tasks']]
            file_task_name = "_".join(task_names[:3])
            if len(task_names) > 3:
                file_task_name += f"_and_{len(task_names)-3}_more"
        else:
            file_task_name = task_info['task_name']
        
        # Run verification
        verification_result = verifier.verify_uppaal(
            xml_content, file_task_name, task_info, ada_code, language, properties_list
        )
        
        # Check if verification failed and offer repair
        if not verification_result['success'] and verification_result.get('uppaal_output'):
            if nl_requirement and verifier.llm_available:
                max_iterations = config.MAX_LLM_REPAIR_ATTEMPTS
                repair_history = []
                current_code = ada_code
                
                for iteration in range(1, max_iterations + 1):
                    print(f"[REPAIR] Iteration {iteration}/{max_iterations}...")
                    
                    repaired_code, repair_error = verifier.repair_counterexample(
                        current_code, 
                        verification_result['uppaal_output'],
                        task_info,
                        language
                    )
                    
                    if repair_error or not repaired_code:
                        break
                    
                    # Re-verify repaired code
                    repaired_task_info = verifier.extract_from_code(repaired_code, language)
                    repaired_xml, repaired_properties = verifier.generate_uppaal_xml(repaired_task_info)
                    repaired_result = verifier.verify_uppaal(
                        repaired_xml, 
                        file_task_name + f"_repair{iteration}", 
                        repaired_task_info, 
                        repaired_code, 
                        language
                    )
                    
                    repair_history.append({
                        'iteration': iteration,
                        'code': repaired_code,
                        'success': repaired_result['success'],
                        'properties_verified': repaired_result.get('properties_verified', 0)
                    })
                    
                    if repaired_result['success']:
                        return jsonify({
                            'repair_converged': True,
                            'success': True,
                            'iterations': iteration,
                            'max_attempts': max_iterations,
                            'original_code': ada_code,
                            'repaired_code': repaired_code,
                            'repair_history': repair_history,
                            'task_info': repaired_task_info,
                            'xml_content': repaired_xml,
                            'verification': repaired_result,
                            'priority_report': priority_report,
                            'schedulability': {
                                'total_utilization': f"{sched_result.total_utilization*100:.1f}%",
                                'll_bound': f"{sched_result.ll_bound*100:.1f}%",
                                'is_schedulable': sched_result.is_schedulable
                            },
                            'repair_trail': repair_trail,
                            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        })
                    
                    current_code = repaired_code
                    verification_result = repaired_result
                    task_info = repaired_task_info
                
                # Failed to converge
                return jsonify({
                    'repair_failed': True,
                    'iterations': len(repair_history),
                    'original_code': ada_code,
                    'repair_history': repair_history,
                    'verification': verification_result
                })
        
        # Return successful result
        return jsonify({
            'success': True,
            'task_info': task_info,
            'xml_content': xml_content,
            'verification': verification_result,
            'priority_report': priority_report,
            'schedulability': {
                'total_utilization': f"{sched_result.total_utilization*100:.1f}%",
                'll_bound': f"{sched_result.ll_bound*100:.1f}%",
                'is_schedulable': sched_result.is_schedulable
            },
            'task_issues': task_issues,
            'repair_trail': repair_trail,
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@verification_bp.route('/download/<filename>')
def download_file(filename):
    """Download verification result file."""
    try:
        filepath = os.path.join(verifier.results_folder, filename)
        if os.path.exists(filepath):
            return send_file(filepath, as_attachment=True)
        else:
            return jsonify({'error': 'File not found'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 500
